#include "oled.h"
#include "user_list.h"
#include <stdarg.h>
#include <string.h>

#define OLED_QUEUE_SIZE 5
#define OLED_TASK_STACK_SIZE 2048
#define OLED_TASK_PRIORITY 3

static const char *TAG = "OLED";
static esp_lcd_panel_handle_t panel_handle;

// Debug message system
static QueueHandle_t oled_msg_queue = NULL;
static TaskHandle_t oled_task_handle = NULL;
static volatile bool oled_initialized = false;

// Current display state
static oled_message_t current_message = {0};
static TickType_t message_start_time = 0;

// Simple 1bpp framebuffer - size depends on display configuration
static uint8_t fb[LCD_H_RES * LCD_V_RES / 8];

// 8x14 ASCII font - Struttura con 14 righe di uint8_t per carattere
// Ogni uint8_t rappresenta una riga orizzontale del carattere (8 bit per riga)
static const uint8_t font8x14[95][14] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // Spazio (32)
    {0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18},  // ! (33)
    {0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // " (34)
    {0x00,0x00,0x36,0x36,0x36,0x7F,0x36,0x36,0x7F,0x36,0x36,0x36,0x00,0x00},  // # (35)
    {0x00,0x08,0x08,0x3E,0x6B,0x0B,0x0B,0x3E,0x68,0x68,0x6B,0x3E,0x08,0x08},  // $ (36)
    {0x63,0x63,0x33,0x33,0x18,0x0C,0x06,0x03,0x33,0x33,0x63,0x63,0x00,0x00},  // % (37)
    {0x0C,0x1E,0x36,0x36,0x1C,0x38,0x6F,0x66,0x66,0x66,0x3B,0x1B,0x3F,0x3E},  // & (38)
    {0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ' (39)
    {0x04,0x08,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x08,0x04},  // ( (40)
    {0x20,0x10,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x10,0x20},  // ) (41)
    {0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00},  // * (42)
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00},  // + (43)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0C,0x06},  // , (44)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // - (45)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18},  // . (46)
    {0x00,0x01,0x03,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},  // / (47)
    {0x3E,0x7F,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 0 (48)
    {0x0C,0x1C,0x3C,0x7C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x7F},  // 1 (49)
    {0x3E,0x7F,0x63,0x03,0x03,0x06,0x0C,0x18,0x30,0x60,0x63,0x63,0x7F,0x7F},  // 2 (50)    
    {0x3E,0x7F,0x63,0x03,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x63,0x7F,0x3E},  // 3 (51)    
    {0x06,0x0E,0x1E,0x36,0x66,0x66,0x66,0x7F,0x7F,0x06,0x06,0x06,0x0F,0x0F},  // 4 (52)
    {0x7F,0x7F,0x60,0x60,0x60,0x7E,0x7F,0x03,0x03,0x03,0x63,0x63,0x7F,0x3E},  // 5 (53)
    {0x1E,0x3F,0x30,0x60,0x60,0x60,0x7E,0x7F,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 6 (54)
    {0x7F,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x18,0x18,0x18},  // 7 (55)
    {0x3E,0x7F,0x63,0x63,0x63,0x3E,0x3E,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 8 (56)
    {0x3E,0x7F,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x03,0x06,0x0C,0x3C,0x38},  // 9 (57)
    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},  // : (58)
    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0C,0x06,0x00,0x00,0x00},  // ; (59)
    {0x00,0x06,0x0C,0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x0C,0x06,0x00,0x00},  // < (60)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00},  // = (61)
    {0x00,0x60,0x30,0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x30,0x60,0x00,0x00},  // > (62)
    {0x00,0x00,0x00,0x3E,0x63,0x63,0x03,0x06,0x0C,0x18,0x18,0x00,0x18,0x18},  // ? (63)
    {0x00,0x00,0x3E,0x63,0x63,0x63,0x6F,0x6F,0x6F,0x6E,0x60,0x60,0x3E,0x00},  // @ (64)
    {0x08,0x1C,0x3E,0x36,0x63,0x63,0x63,0x7F,0x7F,0x63,0x63,0x63,0x63,0x63},  // A (65)
    {0x7E,0x7F,0x33,0x33,0x33,0x3E,0x3E,0x33,0x33,0x33,0x33,0x33,0x7F,0x7E},  // B (66)
    {0x1E,0x3F,0x33,0x63,0x60,0x60,0x60,0x60,0x60,0x63,0x33,0x33,0x3F,0x1E},  // C (67)
    {0x7C,0x7E,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x36,0x7E,0x7C},  // D (68)
    {0x7F,0x7F,0x33,0x30,0x30,0x3E,0x3E,0x30,0x30,0x30,0x33,0x33,0x7F,0x7F},  // E (69)
    {0x7F,0x7F,0x33,0x30,0x30,0x3E,0x3E,0x30,0x30,0x30,0x30,0x30,0x78,0x78},  // F (70)
    {0x1E,0x3F,0x33,0x63,0x60,0x60,0x60,0x67,0x67,0x63,0x63,0x33,0x3F,0x1F},  // G (71)
    {0x63,0x63,0x63,0x63,0x63,0x7F,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x63},  // H (72)
    {0x3C,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // I (73)
    {0x0F,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x66,0x3C,0x38},  // J (74)
    {0x73,0x73,0x33,0x36,0x36,0x3C,0x3C,0x36,0x36,0x33,0x33,0x33,0x63,0x63},  // K (75)
    {0xF8,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7F,0xFF},  // L (76)
    {0x63,0x77,0x7F,0x7F,0x7F,0x6B,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x63},  // M (77)
    {0x63,0x73,0x73,0x7B,0x7B,0x7F,0x6F,0x6F,0x67,0x67,0x63,0x63,0x63,0x63},  // N (78)
    {0x1C,0x3E,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x3E,0x1C},  // O (79)
    {0x7E,0x7F,0x33,0x33,0x33,0x33,0x3E,0x3E,0x30,0x30,0x30,0x30,0x78,0x78},  // P (80)
    {0x3E,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x1E,0x07,0x03},  // Q (81)
    {0x7E,0x7F,0x33,0x33,0x33,0x3E,0x3C,0x36,0x36,0x33,0x33,0x33,0x73,0x63},  // R (82)
    {0x3E,0x7F,0x63,0x63,0x30,0x18,0x0C,0x06,0x03,0x63,0x63,0x63,0x7F,0x3E},  // S (83)
    {0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // T (84)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // U (85)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x3E,0x1C,0x1C,0x08},  // V (86)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x7F,0x36,0x36,0x36,0x36},  // W (87)
    {0x63,0x63,0x63,0x36,0x36,0x1C,0x1C,0x1C,0x36,0x36,0x63,0x63,0x63,0x63},  // X (88)
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // Y (89)
    {0x7F,0x7F,0x63,0x06,0x0C,0x18,0x30,0x30,0x60,0x61,0x63,0x63,0x7F,0x7F},  // Z (90)
    {0x3C,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x3C},  // [ (91)
    {0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x01,0x00,0x00,0x00,0x00},  // \ (92)
    {0x3C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x3C},  // ] (93)
    {0x10,0x38,0x38,0x6C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ^ (94)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},  // _ (95)
    {0x18,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ` (96)
    {0x00,0x00,0x00,0x00,0x3C,0x7E,0x06,0x3E,0x7E,0x66,0x66,0x66,0x7B,0x3B},  // a (97)
    {0x70,0x70,0x30,0x30,0x30,0x3C,0x7E,0x36,0x33,0x33,0x33,0x33,0x7E,0x6E},  // b (98)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x60,0x60,0x60,0x60,0x63,0x7F,0x3E},  // c (99)
    {0x0E,0x0E,0x06,0x06,0x06,0x3E,0x7E,0x66,0x66,0x66,0x66,0x66,0x7F,0x3B},  // d (100)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x63,0x7F,0x7F,0x60,0x63,0x7F,0x3E},  // e (101)
    {0x1C,0x3E,0x36,0x30,0x30,0x7C,0x7C,0x30,0x30,0x30,0x30,0x30,0x78,0x78},  // f (102)
    {0x00,0x00,0x00,0x00,0x3B,0x7F,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x7C},  // g (103)
    {0x70,0x70,0x30,0x30,0x36,0x3B,0x7F,0x33,0x33,0x33,0x33,0x33,0x73,0x73},  // h (104)
    {0x00,0x18,0x18,0x00,0x38,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // i (105)
    {0x00,0x06,0x06,0x00,0x0E,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x7E,0x3C},  // j (106)
    {0x70,0x70,0x30,0x30,0x33,0x36,0x3C,0x3C,0x3C,0x36,0x33,0x33,0x73,0x73},  // k (107)
    {0x38,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // l (108)
    {0x00,0x00,0x00,0x00,0x76,0xFF,0xFF,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B},  // m (109)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33},  // n (110)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // o (111)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78},  // p (112)
    {0x00,0x00,0x00,0x00,0x3B,0x7F,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F},  // q (113)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x3B,0x33,0x30,0x30,0x30,0x30,0x78,0x78},  // r (114)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x38,0x1C,0x0E,0x63,0x63,0x7F,0x3E},  // s (115)
    {0x00,0x10,0x30,0x30,0x7C,0x7C,0x30,0x30,0x30,0x30,0x36,0x36,0x1C,0x1C},  // t (116)
    {0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x7F,0x3B},  // u (117)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08},  // v (118)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x7F,0x36,0x36},  // w (119)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x63,0x63},  // x (120)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x7C},  // y (121)
    {0x00,0x00,0x00,0x00,0x7F,0x7F,0x66,0x0C,0x18,0x30,0x63,0x63,0x7F,0x7F},  // z (122)
    {0x0E,0x1E,0x18,0x18,0x18,0x18,0x70,0x70,0x18,0x18,0x18,0x18,0x1E,0x0E},  // { (123)
    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},  // | (124)
    {0x70,0x78,0x18,0x18,0x18,0x18,0x0E,0x0E,0x18,0x18,0x18,0x18,0x78,0x70},  // } (125)
    {0x3B,0x7F,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}   // ~ (126)
};

// BLE icons 14x20 HORIZONTAL (3 bytes per row x 14 rows = 42 bytes)
static const uint8_t ble_icons_14x20[][42] = {
    // ICON_BLE_CONNECTED - Bluetooth symbol with signal waves 14x20
    {0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x33, 0x00, 0x00, 0x36, 0x80, 0x3C, 0x3C, 0x40, 0x06, 0x36, 0x20, 0x03, 0x33, 0x00, 0x01, 0xB1, 0x80,
     0x01, 0xB1, 0x80, 0x03, 0x33, 0x00, 0x06, 0x36, 0x20, 0x3C, 0x3C, 0x40, 0x00, 0x36, 0x80, 0x00, 0x33, 0x00},
    
    // ICON_BLE_DISCONNECTED - Bluetooth with X overlay and signal waves 14x20
    {0x80, 0x30, 0x10, 0x40, 0x30, 0x20, 0x20, 0x33, 0x40, 0x10, 0x36, 0x80, 0x3C, 0x3C, 0x40, 0x0E, 0x36, 0xE0, 0x07, 0x33, 0xC0, 0x03, 0xB1, 0x80,
     0x03, 0xB1, 0x80, 0x07, 0x33, 0xC0, 0x0E, 0x36, 0xE0, 0x3C, 0x3C, 0x40, 0x10, 0x36, 0x80, 0x20, 0x33, 0x40}
};

// USB icons HORIZONTAL 20x14 (3 bytes per row x 14 rows = 42 bytes)
static const uint8_t usb_icons_20x14[][42] = {
    // USB_CONNECTED - Clear USB connector shape 20x14 HORIZONTAL
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x00, 0x07, 0x01, 0x80, 0x07, 0x01, 0x80, 0x07, 0xFF, 0x80,
     0x01, 0x80, 0x00, 0x01, 0x98, 0x00, 0x01, 0xF8, 0x00, 0x01, 0xF8, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00,
     0x01, 0xF8, 0x00, 0x03, 0xFC, 0x00},
    
    // USB_DISCONNECTED - USB with X overlay 20x14 HORIZONTAL  
    {0x80, 0x00, 0x10, 0x40, 0x00, 0x20, 0x67, 0xFE, 0x60, 0x27, 0x02, 0xE0, 0x17, 0x01, 0xC0, 0x0F, 0xFF, 0x80,
     0x1B, 0x80, 0xD0, 0x11, 0x98, 0x80, 0x01, 0xF8, 0x00, 0x01, 0xF8, 0x00, 0x80, 0xF0, 0x10, 0x40, 0xF0, 0x20,
     0x21, 0xF8, 0x40, 0x13, 0xFC, 0x80}
};

// Battery icons 20x10 HORIZONTAL (3 bytes per row x 10 rows = 30 bytes)
static const uint8_t battery_icons_20x10[][30] = {
    // ICON_BATTERY_FULL - Horizontal full battery 20x10
    {0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8,
     0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF0},
    
    // ICON_BATTERY_HIGH - Horizontal high battery 20x10 (75%)
    {0xFF, 0xFF, 0xF0, 0x80, 0x00, 0x38, 0xFF, 0xFF, 0x38, 0xFF, 0xFF, 0x38, 0xFF, 0xFF, 0x38,
     0xFF, 0xFF, 0x38, 0xFF, 0xFF, 0x38, 0xFF, 0xFF, 0x38, 0x80, 0x00, 0x38, 0xFF, 0xFF, 0xF0},
    
    // ICON_BATTERY_MEDIUM - Horizontal medium battery 20x10 (50%)
    {0xFF, 0xFF, 0xF0, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0xFF, 0x00, 0x38, 0xFF, 0x00, 0x38,
     0xFF, 0x00, 0x38, 0xFF, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0xFF, 0xFF, 0xF0},
    
    // ICON_BATTERY_LOW - Horizontal low battery 20x10 (25%)
    {0xFF, 0xFF, 0xF0, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0xF0, 0x00, 0x38,
     0xF0, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0xFF, 0xFF, 0xF0},
    
    // ICON_BATTERY_EMPTY - Horizontal empty battery 20x10
    {0xFF, 0xFF, 0xF0, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38,
     0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0x80, 0x00, 0x38, 0xFF, 0xFF, 0xF0}
};

static inline void fb_clear(void) {
    memset(fb, 0x00, sizeof(fb));
}

static inline void fb_set_pixel(int x, int y, bool on) {
    if (x < 0 || x >= LCD_H_RES || y < 0 || y >= LCD_V_RES) return;
    size_t idx = x + (y / 8) * LCD_H_RES; // page-oriented
    uint8_t bit = 1u << (y % 8);
    if (on) fb[idx] |= bit; else fb[idx] &= (uint8_t)~bit;
}


// Draw a single character at fixed 8x14 size
static void fb_draw_char_8x14(int x, int y, char c) {
    if (c < 0x20 || c > 0x7E) c = '?';
    if (x < 0 || x + 8 > LCD_H_RES || y < 0 || y + 14 > LCD_V_RES) return;
    
    const uint8_t *glyph = font8x14[c - 0x20];
    for (int row = 0; row < 14; row++) {
        uint8_t rowbits = glyph[row];
        for (int col = 0; col < 8; col++) {
            bool on = (rowbits >> (7-col)) & 0x1; // Bit 7 is leftmost pixel
            if (on) fb_set_pixel(x + col, y + row, true);
        }
    }
}

// Draw a 14x16 icon (BLE icons)
static void fb_draw_ble_14x20(int x, int y, oled_icon_t icon) {
    if (x < 0 || x + 20 > LCD_H_RES || y < 0 || y + 14 > LCD_V_RES) return;
    if (icon > ICON_BLE_DISCONNECTED) return; // Only BLE icons are 14x20
    
    const uint8_t *icon_data = ble_icons_14x20[icon];
    for (int row = 0; row < 14; row++) {
        // Each row uses 3 bytes (24 bits, first 20 are used)
        uint32_t rowbits = (icon_data[row * 3] << 16) | (icon_data[row * 3 + 1] << 8) | icon_data[row * 3 + 2];
        for (int col = 0; col < 20; col++) {
            bool on = (rowbits >> (23-col)) & 0x1; // Bit 23 is leftmost pixel
            if (on) fb_set_pixel(x + col, y + row, true);
        }
    }
}

// Draw an 18x14 USB icon
static void fb_draw_usb_20x14(int x, int y, bool connected) {
    if (x < 0 || x + 20 > LCD_H_RES || y < 0 || y + 14 > LCD_V_RES) return;
    
    int usb_index = connected ? 0 : 1;
    const uint8_t *icon_data = usb_icons_20x14[usb_index];
    
    for (int row = 0; row < 14; row++) {
        // Each row uses 3 bytes (24 bits, first 20 are used)
        uint32_t rowbits = (icon_data[row * 3] << 16) | (icon_data[row * 3 + 1] << 8) | icon_data[row * 3 + 2];
        for (int col = 0; col < 20; col++) {
            bool on = (rowbits >> (23-col)) & 0x1; // Bit 23 is leftmost pixel
            if (on) fb_set_pixel(x + col, y + row, true);
        }
    }
}

// Draw a 20x10 horizontal battery icon
static void fb_draw_battery_20x10(int x, int y, oled_icon_t icon) {
    if (x < 0 || x + 20 > LCD_H_RES || y < 0 || y + 10 > LCD_V_RES) return;
    
    // Map battery icons to battery array indices
    int battery_index = -1;
    switch(icon) {
        case ICON_BATTERY_FULL: battery_index = 0; break;
        case ICON_BATTERY_HIGH: battery_index = 1; break;
        case ICON_BATTERY_MEDIUM: battery_index = 2; break;
        case ICON_BATTERY_LOW: battery_index = 3; break;
        case ICON_BATTERY_EMPTY: battery_index = 4; break;
        default: return;
    }
    
    const uint8_t *icon_data = battery_icons_20x10[battery_index];
    for (int row = 0; row < 10; row++) {
        // Each row uses 3 bytes (24 bits, but only first 20 are used)
        uint32_t rowbits = (icon_data[row * 3] << 16) | (icon_data[row * 3 + 1] << 8) | icon_data[row * 3 + 2];
        for (int col = 0; col < 20; col++) {
            bool on = (rowbits >> (23-col)) & 0x1; // Bit 23 is leftmost pixel
            if (on) fb_set_pixel(x + col, y + row, true);
        }
    }
}

static void fb_draw_text_8x14(const char *text) {
    fb_clear();
    
    int x = 0;
    int y = 0;
    int line = 0;
    
    // For 128x32 display, start text from bottom to leave space for status icons
    #if OLED_TYPE == OLED_128x32
        int max_lines = 2; // 32px / 14px ≈ 2 lines max
        y = LCD_V_RES - OLED_FONT_HEIGHT; // Start from bottom (32-14=18)
    #else
        int max_lines = LCD_V_RES / OLED_FONT_HEIGHT; // For 96x16: 16/14=1 line
    #endif
    
    for (const char *p = text; *p && line < max_lines; ++p) {
        if (*p == '\n' || x + OLED_FONT_WIDTH > LCD_H_RES) {
            // Move to next line
            line++;
            if (line >= max_lines) break;
            x = 0;
            #if OLED_TYPE == OLED_128x32
                y = LCD_V_RES - OLED_FONT_HEIGHT + (line * OLED_FONT_HEIGHT); // Still bottom-aligned for multiline
            #else
                y = line * OLED_FONT_HEIGHT;
            #endif
            if (*p == '\n') continue; // Skip the newline character
        }
        
        if (y + OLED_FONT_HEIGHT <= LCD_V_RES) {
            fb_draw_char_8x14(x, y, *p);
            x += OLED_FONT_WIDTH;
        }
    }
}


static void oled_flush(void) {
    // Draw full frame buffer to panel
    // SSD1306 expects page order; esp_lcd driver accepts a packed 1bpp buffer.
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, fb);
}

static void oled_display_message(const oled_message_t* msg) {
    if (!oled_initialized) return;
    // Use fixed 8x14 font for all messages
    fb_draw_text_8x14(msg->text);
    oled_flush();

    // Update current message tracking
    current_message = *msg;
    message_start_time = xTaskGetTickCount();
}

static void oled_task(void *pvParameters) {
    oled_message_t msg;
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        // Check for new messages (non-blocking)
    if (xQueueReceive(oled_msg_queue, &msg, 0) == (BaseType_t)pdTRUE) {
            // New message received - display immediately (replaces current)
            oled_display_message(&msg);
        } else {
            // No new message - check if current message should be cleared
            if (current_message.display_time_ms > 0) {
                TickType_t elapsed = xTaskGetTickCount() - message_start_time;
                if (pdTICKS_TO_MS(elapsed) >= current_message.display_time_ms) {
                    // Time expired - show default message
                    oled_message_t default_msg = {
                        .text = "BLE PassMan",
                        .type = OLED_MSG_TYPE_NORMAL,
                        .display_time_ms = 0
                    };
                    oled_display_message(&default_msg);
                }
            }
        }
        
        // Run at 10Hz to check for message timeouts
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(100));
    }
}

void oled_write_text(const char* text) {
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_NORMAL,
        .display_time_ms = 5000  // Default: 5 secondi poi torna al messaggio di default
    };
    strncpy(msg.text, text, sizeof(msg.text) - 1);
    msg.text[sizeof(msg.text) - 1] = '\0';
    
    if (oled_initialized) {
        oled_send_message(&msg);
    }
}

void oled_write_text_permanent(const char* text) {
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_NORMAL,
        .display_time_ms = 0  // Permanent - non torna mai al default
    };
    strncpy(msg.text, text, sizeof(msg.text) - 1);
    msg.text[sizeof(msg.text) - 1] = '\0';
    
    if (oled_initialized) {
        oled_send_message(&msg);
    }
}

// Icon and status functions
void oled_draw_icon(int x, int y, oled_icon_t icon) {
    if (!oled_initialized) return;
    
    // Use appropriate drawing function based on icon type
    if (icon <= ICON_BLE_DISCONNECTED) {
        fb_draw_ble_14x20(x, y, icon);  // BLE icons are 14x20 HORIZONTAL
    } else if (icon <= ICON_USB_DISCONNECTED) {
        fb_draw_usb_20x14(x, y, icon == ICON_USB_CONNECTED);  // USB icons are 20x14 HORIZONTAL
    } else {
        fb_draw_battery_20x10(x, y, icon);  // Battery icons are 20x10 HORIZONTAL
    }
    oled_flush();
}

void oled_show_status_bar(bool ble_connected, bool usb_connected, int battery_percent) {
    if (!oled_initialized) return;
    if (OLED_TYPE != OLED_128x32) return; // Status bar only for 128x32 display
    
    fb_clear();
    
    // Top row for status icons (y=0) - now using 14px height icons
    int x_pos = 0;
    
    // BLE status icon (14x20 HORIZONTAL)
    fb_draw_ble_14x20(x_pos, 0, ble_connected ? ICON_BLE_CONNECTED : ICON_BLE_DISCONNECTED);
    x_pos += 22; // 20px icon + 2px spacing
    
    // USB status icon (20x14 HORIZONTAL) - always show
    fb_draw_usb_20x14(x_pos, 0, usb_connected);
    x_pos += 22; // 20px icon + 2px spacing
    
    // Battery icon (20x10 HORIZONTAL) and percentage (right-aligned)
    oled_icon_t battery_icon;
    if (battery_percent >= 80) battery_icon = ICON_BATTERY_FULL;
    else if (battery_percent >= 60) battery_icon = ICON_BATTERY_HIGH;
    else if (battery_percent >= 40) battery_icon = ICON_BATTERY_MEDIUM;
    else if (battery_percent >= 20) battery_icon = ICON_BATTERY_LOW;
    else battery_icon = ICON_BATTERY_EMPTY;
    
    // Calculate position for right-aligned battery info
    char battery_text[8];
    snprintf(battery_text, sizeof(battery_text), "%d%%", battery_percent);
    int text_width = strlen(battery_text) * OLED_FONT_WIDTH;
    int battery_x = LCD_H_RES - text_width - 22; // 20px horizontal icon + 2px spacing
    
    fb_draw_battery_20x10(battery_x, 2, battery_icon);  // Centered vertically (y=2 for 10px height)
    
    // Draw battery percentage text (positioned next to 20x10 horizontal icon)
    for (int i = 0; battery_text[i] && i < strlen(battery_text); i++) {
        fb_draw_char_8x14(battery_x + 22 + (i * OLED_FONT_WIDTH), 0, battery_text[i]);
    }
    
    oled_flush();
}

void oled_update_status(bool ble_connected, bool usb_connected, int battery_percent, const char* main_text) {
    if (!oled_initialized) return;
    if (OLED_TYPE != OLED_128x32) {
        // For 96x16 display, just show the main text
        oled_write_text_permanent(main_text);
        return;
    }
    
    fb_clear();
    
    // Top row for status icons (y=0) - using 14px height icons
    int x_pos = 0;
    
    // BLE status icon (14x20 HORIZONTAL)
    fb_draw_ble_14x20(x_pos, 0, ble_connected ? ICON_BLE_CONNECTED : ICON_BLE_DISCONNECTED);
    x_pos += 22; // 20px icon + 2px spacing
    
    // USB status icon (20x14 HORIZONTAL) - always show
    fb_draw_usb_20x14(x_pos, 0, usb_connected);
    x_pos += 22; // 20px icon + 2px spacing
    
    // Battery icon (20x10 HORIZONTAL) and percentage (right-aligned)
    oled_icon_t battery_icon;
    if (battery_percent >= 80) battery_icon = ICON_BATTERY_FULL;
    else if (battery_percent >= 60) battery_icon = ICON_BATTERY_HIGH;
    else if (battery_percent >= 40) battery_icon = ICON_BATTERY_MEDIUM;
    else if (battery_percent >= 20) battery_icon = ICON_BATTERY_LOW;
    else battery_icon = ICON_BATTERY_EMPTY;
    
    char battery_text[8];
    snprintf(battery_text, sizeof(battery_text), "%d%%", battery_percent);
    int text_width = strlen(battery_text) * OLED_FONT_WIDTH;
    int battery_x = LCD_H_RES - text_width - 22; // 20px horizontal icon + 2px spacing
    
    fb_draw_battery_20x10(battery_x, 2, battery_icon);  // Centered vertically (y=2 for 10px height)
    
    // Draw battery percentage text (top row, next to 20x10 horizontal icon)
    for (int i = 0; battery_text[i] && i < strlen(battery_text); i++) {
        fb_draw_char_8x14(battery_x + 22 + (i * OLED_FONT_WIDTH), 0, battery_text[i]);
    }
    
    // Main text centered at bottom (with gap from icons)
    if (main_text && strlen(main_text) > 0) {
        int text_len = strlen(main_text);
        int max_chars = LCD_H_RES / OLED_FONT_WIDTH;
        if (text_len > max_chars) text_len = max_chars;
        
        // Calculate horizontal center position
        int text_width = text_len * OLED_FONT_WIDTH;
        int start_x = (LCD_H_RES - text_width) / 2;
        
        // Position text at bottom with gap from icons (y = LCD_V_RES - OLED_FONT_HEIGHT)
        int text_y = LCD_V_RES - OLED_FONT_HEIGHT;
        
        for (int i = 0; i < text_len; i++) {
            fb_draw_char_8x14(start_x + (i * OLED_FONT_WIDTH), text_y, main_text[i]);
        }
    }
    
    oled_flush();
}

// Enhanced debug functions
void oled_debug_printf(const char* format, ...) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_DEBUG,
        .display_time_ms = 3000  // 3 seconds
    };
    
    va_list args;
    va_start(args, format);
    vsnprintf(msg.text, sizeof(msg.text), format, args);
    va_end(args);
    
    oled_send_message(&msg);
}

void oled_debug_error(const char* error) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_ERROR,
        .display_time_ms = 5000  // 5 seconds for errors
    };
    snprintf(msg.text, sizeof(msg.text), "ERR: %s", error);
    
    oled_send_message(&msg);
}

void oled_debug_status(const char* status) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_STATUS,
        .display_time_ms = 2000  // 2 seconds for status
    };
    snprintf(msg.text, sizeof(msg.text), "%s", status);
    
    oled_send_message(&msg);
}

// void oled_show_temporary(const char* text, uint32_t duration_ms) {
//     if (!oled_initialized) return;
    
//     oled_message_t msg = {
//         .type = OLED_MSG_TYPE_NORMAL,
//         .display_time_ms = duration_ms
//     };
//     strncpy(msg.text, text, sizeof(msg.text) - 1);
//     msg.text[sizeof(msg.text) - 1] = '\0';
    
//     oled_send_message(&msg);
// }

esp_err_t oled_send_message(const oled_message_t* msg) {
    if (!oled_msg_queue || !msg) {
        return ESP_ERR_INVALID_STATE;
    }
    
    // Clear queue if full to always show latest message
    if (uxQueueSpacesAvailable(oled_msg_queue) == 0) {
        oled_message_t dummy;
        xQueueReceive(oled_msg_queue, &dummy, 0);  // Remove oldest message
    }
    
    // Send new message (non-blocking)
    if (xQueueSend(oled_msg_queue, msg, 0) == (BaseType_t)pdTRUE) {
        return ESP_OK;
    }
    
    return ESP_ERR_TIMEOUT;
}

void oled_clear_queue(void) {
    if (oled_msg_queue) {
        xQueueReset(oled_msg_queue);
    }
}

esp_err_t oled_init(void) {
    ESP_LOGI(TAG, "Initialize I2C bus");
    i2c_master_bus_handle_t i2c_bus = NULL;
    i2c_master_bus_config_t bus_config = {
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .i2c_port = I2C_BUS_PORT,
        .sda_io_num = (gpio_num_t)PIN_NUM_SDA,
        .scl_io_num = (gpio_num_t)PIN_NUM_SCL,
        .flags.enable_internal_pullup = true,
    };
    esp_err_t ret = i2c_new_master_bus(&bus_config, &i2c_bus);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create I2C master bus: %s", esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG, "Install panel IO");
    esp_lcd_panel_io_handle_t io_handle = NULL;
    esp_lcd_panel_io_i2c_config_t io_config = {
        .dev_addr = I2C_HW_ADDR,
        .scl_speed_hz = LCD_PIXEL_CLOCK_HZ,
        .control_phase_bytes = 1,               // According to SSD1306 datasheet
        .lcd_cmd_bits = LCD_CMD_BITS,           // According to SSD1306 datasheet
        .lcd_param_bits = LCD_CMD_BITS,         // According to SSD1306 datasheet
        .dc_bit_offset = 6,                     // According to SSD1306 datasheet
    };
    ret = esp_lcd_new_panel_io_i2c(i2c_bus, &io_config, &io_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create panel IO: %s", esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG, "Install SSD1306 panel driver");
    panel_handle = NULL;
    esp_lcd_panel_dev_config_t panel_config = {
        .bits_per_pixel = 1,
        .reset_gpio_num = PIN_NUM_RST,
    };
    esp_lcd_panel_ssd1306_config_t ssd1306_config = {
        .height = LCD_V_RES,
    };
    panel_config.vendor_config = &ssd1306_config;
    ret = esp_lcd_new_panel_ssd1306(io_handle, &panel_config, &panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create SSD1306 panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_reset(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to reset panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_init(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_disp_on_off(panel_handle, true);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to turn on panel: %s", esp_err_to_name(ret));
        return ret;
    }

    // Rotate display 180 degrees to match previous orientation
    // Using panel mirror in both axes is equivalent to 180deg rotation
    esp_lcd_panel_mirror(panel_handle, true, true);

    // Apply horizontal gap (column offset) if configured
    esp_lcd_panel_set_gap(panel_handle, OLED_COLUMN_OFFSET, 4);
    
    // Initialize debug message system
    ESP_LOGI(TAG, "Initialize OLED debug message system");
    oled_msg_queue = xQueueCreate(OLED_QUEUE_SIZE, sizeof(oled_message_t));
    if (oled_msg_queue == NULL) {
        ESP_LOGE(TAG, "Failed to create OLED message queue");
        return ESP_ERR_NO_MEM;
    }
    
    // Create OLED task
    BaseType_t task_created = xTaskCreate(
        oled_task, 
        "oled_task", 
        OLED_TASK_STACK_SIZE, 
        NULL, 
        OLED_TASK_PRIORITY, 
        &oled_task_handle
    );
    
    if (task_created != pdPASS) {
        ESP_LOGE(TAG, "Failed to create OLED task");
        vQueueDelete(oled_msg_queue);
        oled_msg_queue = NULL;
        return ESP_ERR_NO_MEM;
    }
    
    oled_initialized = true;
    ESP_LOGI(TAG, "OLED debug system initialized");

    // Show default banner at startup
    oled_display_message(&(oled_message_t){ .text = "BLE PassMan", .type = OLED_MSG_TYPE_STATUS, .display_time_ms = 0 });
        
    return ESP_OK;
}

void oled_off(void) {
    // Clear the display content
    fb_clear();
    oled_flush();
    ESP_LOGI(TAG, "Turning off OLED display");
    esp_lcd_panel_disp_on_off(panel_handle, false);

    // Clean up debug system
    oled_initialized = false;
    if (oled_task_handle) {
        vTaskDelete(oled_task_handle);
        oled_task_handle = NULL;
    }
    if (oled_msg_queue) {
        vQueueDelete(oled_msg_queue);
        oled_msg_queue = NULL;
    }
}
