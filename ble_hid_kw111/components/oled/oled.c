#include "oled.h"
#include "user_list.h"
#include <stdarg.h>
#include <string.h>

#define OLED_QUEUE_SIZE 5
#define OLED_TASK_STACK_SIZE 2048
#define OLED_TASK_PRIORITY 3

static const char *TAG = "OLED";
static esp_lcd_panel_handle_t panel_handle;

// Debug message system
static QueueHandle_t oled_msg_queue = NULL;
static TaskHandle_t oled_task_handle = NULL;
static volatile bool oled_initialized = false;

// Current display state
static oled_message_t current_message = {0};
static TickType_t message_start_time = 0;

// Simple 1bpp framebuffer (128x16 => 256 bytes)
static uint8_t fb[LCD_H_RES * LCD_V_RES / 8];

// 8x14 ASCII font - Struttura con 14 righe di uint8_t per carattere
// Ogni uint8_t rappresenta una riga orizzontale del carattere (8 bit per riga)
static const uint8_t font8x14[95][14] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // Spazio (32)
    {0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18},  // ! (33)
    {0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // " (34)
    {0x00,0x00,0x36,0x36,0x36,0x7F,0x36,0x36,0x7F,0x36,0x36,0x36,0x00,0x00},  // # (35)
    {0x00,0x08,0x08,0x3E,0x6B,0x0B,0x0B,0x3E,0x68,0x68,0x6B,0x3E,0x08,0x08},  // $ (36)
    {0x63,0x63,0x33,0x33,0x18,0x0C,0x06,0x03,0x33,0x33,0x63,0x63,0x00,0x00},  // % (37)
    {0x0C,0x1E,0x36,0x36,0x1C,0x38,0x6F,0x66,0x66,0x66,0x3B,0x1B,0x3F,0x3E},  // & (38)
    {0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ' (39)
    {0x04,0x08,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x08,0x04},  // ( (40)
    {0x20,0x10,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x10,0x20},  // ) (41)
    {0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00},  // * (42)
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00},  // + (43)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0C,0x06},  // , (44)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // - (45)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18},  // . (46)
    {0x00,0x01,0x03,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},  // / (47)
    {0x3E,0x7F,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 0 (48)
    {0x0C,0x1C,0x3C,0x7C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x7F},  // 1 (49)
    {0x3E,0x7F,0x63,0x03,0x03,0x06,0x0C,0x18,0x30,0x60,0x63,0x63,0x7F,0x7F},  // 2 (50)    
    {0x3E,0x7F,0x63,0x03,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x63,0x7F,0x3E},  // 3 (51)    
    {0x06,0x0E,0x1E,0x36,0x66,0x66,0x66,0x7F,0x7F,0x06,0x06,0x06,0x0F,0x0F},  // 4 (52)
    {0x7F,0x7F,0x60,0x60,0x60,0x7E,0x7F,0x03,0x03,0x03,0x63,0x63,0x7F,0x3E},  // 5 (53)
    {0x1E,0x3F,0x30,0x60,0x60,0x60,0x7E,0x7F,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 6 (54)
    {0x7F,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x18,0x18,0x18},  // 7 (55)
    {0x3E,0x7F,0x63,0x63,0x63,0x3E,0x3E,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // 8 (56)
    {0x3E,0x7F,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x03,0x06,0x0C,0x3C,0x38},  // 9 (57)
    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},  // : (58)
    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0C,0x06,0x00,0x00,0x00},  // ; (59)
    {0x00,0x06,0x0C,0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x0C,0x06,0x00,0x00},  // < (60)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00},  // = (61)
    {0x00,0x60,0x30,0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x30,0x60,0x00,0x00},  // > (62)
    {0x00,0x00,0x00,0x3E,0x63,0x63,0x03,0x06,0x0C,0x18,0x18,0x00,0x18,0x18},  // ? (63)
    {0x00,0x00,0x3E,0x63,0x63,0x63,0x6F,0x6F,0x6F,0x6E,0x60,0x60,0x3E,0x00},  // @ (64)
    {0x08,0x1C,0x3E,0x36,0x63,0x63,0x63,0x7F,0x7F,0x63,0x63,0x63,0x63,0x63},  // A (65)
    {0x7E,0x7F,0x33,0x33,0x33,0x3E,0x3E,0x33,0x33,0x33,0x33,0x33,0x7F,0x7E},  // B (66)
    {0x1E,0x3F,0x33,0x63,0x60,0x60,0x60,0x60,0x60,0x63,0x33,0x33,0x3F,0x1E},  // C (67)
    {0x7C,0x7E,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x36,0x7E,0x7C},  // D (68)
    {0x7F,0x7F,0x33,0x30,0x30,0x3E,0x3E,0x30,0x30,0x30,0x33,0x33,0x7F,0x7F},  // E (69)
    {0x7F,0x7F,0x33,0x30,0x30,0x3E,0x3E,0x30,0x30,0x30,0x30,0x30,0x78,0x78},  // F (70)
    {0x1E,0x3F,0x33,0x63,0x60,0x60,0x60,0x67,0x67,0x63,0x63,0x33,0x3F,0x1F},  // G (71)
    {0x63,0x63,0x63,0x63,0x63,0x7F,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x63},  // H (72)
    {0x3C,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // I (73)
    {0x0F,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x66,0x3C,0x38},  // J (74)
    {0x73,0x73,0x33,0x36,0x36,0x3C,0x3C,0x36,0x36,0x33,0x33,0x33,0x63,0x63},  // K (75)
    {0xF8,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7F,0xFF},  // L (76)
    {0x63,0x77,0x7F,0x7F,0x7F,0x6B,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x63},  // M (77)
    {0x63,0x73,0x73,0x7B,0x7B,0x7F,0x6F,0x6F,0x67,0x67,0x63,0x63,0x63,0x63},  // N (78)
    {0x1C,0x3E,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x3E,0x1C},  // O (79)
    {0x7E,0x7F,0x33,0x33,0x33,0x33,0x3E,0x3E,0x30,0x30,0x30,0x30,0x78,0x78},  // P (80)
    {0x3E,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x1E,0x07,0x03},  // Q (81)
    {0x7E,0x7F,0x33,0x33,0x33,0x3E,0x3C,0x36,0x36,0x33,0x33,0x33,0x73,0x63},  // R (82)
    {0x3E,0x7F,0x63,0x63,0x30,0x18,0x0C,0x06,0x03,0x63,0x63,0x63,0x7F,0x3E},  // S (83)
    {0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // T (84)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // U (85)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x3E,0x1C,0x1C,0x08},  // V (86)
    {0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x7F,0x36,0x36,0x36,0x36},  // W (87)
    {0x63,0x63,0x63,0x36,0x36,0x1C,0x1C,0x1C,0x36,0x36,0x63,0x63,0x63,0x63},  // X (88)
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // Y (89)
    {0x7F,0x7F,0x63,0x06,0x0C,0x18,0x30,0x30,0x60,0x61,0x63,0x63,0x7F,0x7F},  // Z (90)
    {0x3C,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x3C},  // [ (91)
    {0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x01,0x00,0x00,0x00,0x00},  // \ (92)
    {0x3C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x3C},  // ] (93)
    {0x10,0x38,0x38,0x6C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ^ (94)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},  // _ (95)
    {0x18,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  // ` (96)
    {0x00,0x00,0x00,0x00,0x3C,0x7E,0x06,0x3E,0x7E,0x66,0x66,0x66,0x7B,0x3B},  // a (97)
    {0x70,0x70,0x30,0x30,0x30,0x3C,0x7E,0x36,0x33,0x33,0x33,0x33,0x7E,0x6E},  // b (98)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x60,0x60,0x60,0x60,0x63,0x7F,0x3E},  // c (99)
    {0x0E,0x0E,0x06,0x06,0x06,0x3E,0x7E,0x66,0x66,0x66,0x66,0x66,0x7F,0x3B},  // d (100)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x63,0x7F,0x7F,0x60,0x63,0x7F,0x3E},  // e (101)
    {0x1C,0x3E,0x36,0x30,0x30,0x7C,0x7C,0x30,0x30,0x30,0x30,0x30,0x78,0x78},  // f (102)
    {0x00,0x00,0x00,0x00,0x3B,0x7F,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x7C},  // g (103)
    {0x70,0x70,0x30,0x30,0x36,0x3B,0x7F,0x33,0x33,0x33,0x33,0x33,0x73,0x73},  // h (104)
    {0x00,0x18,0x18,0x00,0x38,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // i (105)
    {0x00,0x06,0x06,0x00,0x0E,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x7E,0x3C},  // j (106)
    {0x70,0x70,0x30,0x30,0x33,0x36,0x3C,0x3C,0x3C,0x36,0x33,0x33,0x73,0x73},  // k (107)
    {0x38,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x3C},  // l (108)
    {0x00,0x00,0x00,0x00,0x76,0xFF,0xFF,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B},  // m (109)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33},  // n (110)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x3E},  // o (111)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78},  // p (112)
    {0x00,0x00,0x00,0x00,0x3B,0x7F,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F},  // q (113)
    {0x00,0x00,0x00,0x00,0x6E,0x7F,0x3B,0x33,0x30,0x30,0x30,0x30,0x78,0x78},  // r (114)
    {0x00,0x00,0x00,0x00,0x3E,0x7F,0x63,0x38,0x1C,0x0E,0x63,0x63,0x7F,0x3E},  // s (115)
    {0x00,0x10,0x30,0x30,0x7C,0x7C,0x30,0x30,0x30,0x30,0x36,0x36,0x1C,0x1C},  // t (116)
    {0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x7F,0x3B},  // u (117)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08},  // v (118)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x7F,0x36,0x36},  // w (119)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x63,0x63},  // x (120)
    {0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x7C},  // y (121)
    {0x00,0x00,0x00,0x00,0x7F,0x7F,0x66,0x0C,0x18,0x30,0x63,0x63,0x7F,0x7F},  // z (122)
    {0x0E,0x1E,0x18,0x18,0x18,0x18,0x70,0x70,0x18,0x18,0x18,0x18,0x1E,0x0E},  // { (123)
    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},  // | (124)
    {0x70,0x78,0x18,0x18,0x18,0x18,0x0E,0x0E,0x18,0x18,0x18,0x18,0x78,0x70},  // } (125)
    {0x3B,0x7F,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}   // ~ (126)
};
    

static inline void fb_clear(void) {
    memset(fb, 0x00, sizeof(fb));
}

static inline void fb_set_pixel(int x, int y, bool on) {
    if (x < 0 || x >= LCD_H_RES || y < 0 || y >= LCD_V_RES) return;
    size_t idx = x + (y / 8) * LCD_H_RES; // page-oriented
    uint8_t bit = 1u << (y % 8);
    if (on) fb[idx] |= bit; else fb[idx] &= (uint8_t)~bit;
}


// Draw a single character at fixed 8x14 size
static void fb_draw_char_8x14(int x, int y, char c) {
    if (c < 0x20 || c > 0x7E) c = '?';
    if (x < 0 || x + 8 > LCD_H_RES || y < 0 || y + 14 > LCD_V_RES) return;
    
    const uint8_t *glyph = font8x14[c - 0x20];
    for (int row = 0; row < 14; row++) {
        uint8_t rowbits = glyph[row];
        for (int col = 0; col < 8; col++) {
            bool on = (rowbits >> (7-col)) & 0x1; // Bit 7 is leftmost pixel
            if (on) fb_set_pixel(x + col, y + row, true);
        }
    }
}

static void fb_draw_text_8x14(const char *text) {
    fb_clear();
    int y = 0; // Start from top - no offset for now to see if it appears
    int x = 0;
    
    for (const char *p = text; *p && x + 8 <= LCD_H_RES; ++p) {
        fb_draw_char_8x14(x, y, *p);
        x += 8; // Fixed 8-pixel width, no spacing
    }
}


static void oled_flush(void) {
    // Draw full frame buffer to panel
    // SSD1306 expects page order; esp_lcd driver accepts a packed 1bpp buffer.
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, fb);
}

static void oled_display_message(const oled_message_t* msg) {
    if (!oled_initialized) return;
    // Use fixed 8x14 font for all messages
    fb_draw_text_8x14(msg->text);
    oled_flush();

    // Update current message tracking
    current_message = *msg;
    message_start_time = xTaskGetTickCount();
}

static void oled_task(void *pvParameters) {
    oled_message_t msg;
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        // Check for new messages (non-blocking)
    if (xQueueReceive(oled_msg_queue, &msg, 0) == (BaseType_t)pdTRUE) {
            // New message received - display immediately (replaces current)
            oled_display_message(&msg);
        } else {
            // No new message - check if current message should be cleared
            if (current_message.display_time_ms > 0) {
                TickType_t elapsed = xTaskGetTickCount() - message_start_time;
                if (pdTICKS_TO_MS(elapsed) >= current_message.display_time_ms) {
                    // Time expired - show default message
                    oled_message_t default_msg = {
                        .text = "BLE PassMan",
                        .type = OLED_MSG_TYPE_NORMAL,
                        .display_time_ms = 0
                    };
                    oled_display_message(&default_msg);
                }
            }
        }
        
        // Run at 10Hz to check for message timeouts
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(100));
    }
}

void oled_write_text(const char* text) {
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_NORMAL,
        .display_time_ms = 5000  // Default: 5 secondi poi torna al messaggio di default
    };
    strncpy(msg.text, text, sizeof(msg.text) - 1);
    msg.text[sizeof(msg.text) - 1] = '\0';
    
    if (oled_initialized) {
        oled_send_message(&msg);
    }
}

void oled_write_text_permanent(const char* text) {
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_NORMAL,
        .display_time_ms = 0  // Permanent - non torna mai al default
    };
    strncpy(msg.text, text, sizeof(msg.text) - 1);
    msg.text[sizeof(msg.text) - 1] = '\0';
    
    if (oled_initialized) {
        oled_send_message(&msg);
    }
}

// Enhanced debug functions
void oled_debug_printf(const char* format, ...) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_DEBUG,
        .display_time_ms = 3000  // 3 seconds
    };
    
    va_list args;
    va_start(args, format);
    vsnprintf(msg.text, sizeof(msg.text), format, args);
    va_end(args);
    
    oled_send_message(&msg);
}

void oled_debug_error(const char* error) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_ERROR,
        .display_time_ms = 5000  // 5 seconds for errors
    };
    snprintf(msg.text, sizeof(msg.text), "ERR: %s", error);
    
    oled_send_message(&msg);
}

void oled_debug_status(const char* status) {
    if (!oled_initialized) return;
    
    oled_message_t msg = {
        .type = OLED_MSG_TYPE_STATUS,
        .display_time_ms = 2000  // 2 seconds for status
    };
    snprintf(msg.text, sizeof(msg.text), "%s", status);
    
    oled_send_message(&msg);
}

// void oled_show_temporary(const char* text, uint32_t duration_ms) {
//     if (!oled_initialized) return;
    
//     oled_message_t msg = {
//         .type = OLED_MSG_TYPE_NORMAL,
//         .display_time_ms = duration_ms
//     };
//     strncpy(msg.text, text, sizeof(msg.text) - 1);
//     msg.text[sizeof(msg.text) - 1] = '\0';
    
//     oled_send_message(&msg);
// }

esp_err_t oled_send_message(const oled_message_t* msg) {
    if (!oled_msg_queue || !msg) {
        return ESP_ERR_INVALID_STATE;
    }
    
    // Clear queue if full to always show latest message
    if (uxQueueSpacesAvailable(oled_msg_queue) == 0) {
        oled_message_t dummy;
        xQueueReceive(oled_msg_queue, &dummy, 0);  // Remove oldest message
    }
    
    // Send new message (non-blocking)
    if (xQueueSend(oled_msg_queue, msg, 0) == (BaseType_t)pdTRUE) {
        return ESP_OK;
    }
    
    return ESP_ERR_TIMEOUT;
}

void oled_clear_queue(void) {
    if (oled_msg_queue) {
        xQueueReset(oled_msg_queue);
    }
}

esp_err_t oled_init(void) {
    ESP_LOGI(TAG, "Initialize I2C bus");
    i2c_master_bus_handle_t i2c_bus = NULL;
    i2c_master_bus_config_t bus_config = {
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .i2c_port = I2C_BUS_PORT,
        .sda_io_num = (gpio_num_t)PIN_NUM_SDA,
        .scl_io_num = (gpio_num_t)PIN_NUM_SCL,
        .flags.enable_internal_pullup = true,
    };
    esp_err_t ret = i2c_new_master_bus(&bus_config, &i2c_bus);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create I2C master bus: %s", esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG, "Install panel IO");
    esp_lcd_panel_io_handle_t io_handle = NULL;
    esp_lcd_panel_io_i2c_config_t io_config = {
        .dev_addr = I2C_HW_ADDR,
        .scl_speed_hz = LCD_PIXEL_CLOCK_HZ,
        .control_phase_bytes = 1,               // According to SSD1306 datasheet
        .lcd_cmd_bits = LCD_CMD_BITS,           // According to SSD1306 datasheet
        .lcd_param_bits = LCD_CMD_BITS,         // According to SSD1306 datasheet
        .dc_bit_offset = 6,                     // According to SSD1306 datasheet
    };
    ret = esp_lcd_new_panel_io_i2c(i2c_bus, &io_config, &io_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create panel IO: %s", esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG, "Install SSD1306 panel driver");
    panel_handle = NULL;
    esp_lcd_panel_dev_config_t panel_config = {
        .bits_per_pixel = 1,
        .reset_gpio_num = PIN_NUM_RST,
    };
    esp_lcd_panel_ssd1306_config_t ssd1306_config = {
        .height = LCD_V_RES,
    };
    panel_config.vendor_config = &ssd1306_config;
    ret = esp_lcd_new_panel_ssd1306(io_handle, &panel_config, &panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create SSD1306 panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_reset(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to reset panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_init(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init panel: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ret = esp_lcd_panel_disp_on_off(panel_handle, true);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to turn on panel: %s", esp_err_to_name(ret));
        return ret;
    }

    // Rotate display 180 degrees to match previous orientation
    // Using panel mirror in both axes is equivalent to 180deg rotation
    esp_lcd_panel_mirror(panel_handle, true, true);

    // Apply horizontal gap (column offset) if configured
    esp_lcd_panel_set_gap(panel_handle, 0, 4);
    
    // Initialize debug message system
    ESP_LOGI(TAG, "Initialize OLED debug message system");
    oled_msg_queue = xQueueCreate(OLED_QUEUE_SIZE, sizeof(oled_message_t));
    if (oled_msg_queue == NULL) {
        ESP_LOGE(TAG, "Failed to create OLED message queue");
        return ESP_ERR_NO_MEM;
    }
    
    // Create OLED task
    BaseType_t task_created = xTaskCreate(
        oled_task, 
        "oled_task", 
        OLED_TASK_STACK_SIZE, 
        NULL, 
        OLED_TASK_PRIORITY, 
        &oled_task_handle
    );
    
    if (task_created != pdPASS) {
        ESP_LOGE(TAG, "Failed to create OLED task");
        vQueueDelete(oled_msg_queue);
        oled_msg_queue = NULL;
        return ESP_ERR_NO_MEM;
    }
    
    oled_initialized = true;
    ESP_LOGI(TAG, "OLED debug system initialized");

    // Show default banner at startup
    oled_display_message(&(oled_message_t){ .text = "BLE PassMan", .type = OLED_MSG_TYPE_STATUS, .display_time_ms = 0 });
        
    return ESP_OK;
}


void oled_off(void) {
    // Clear the display content
    fb_clear();
    oled_flush();
    ESP_LOGI(TAG, "Turning off OLED display");
    esp_lcd_panel_disp_on_off(panel_handle, false);

    // Clean up debug system
    oled_initialized = false;
    if (oled_task_handle) {
        vTaskDelete(oled_task_handle);
        oled_task_handle = NULL;
    }
    if (oled_msg_queue) {
        vQueueDelete(oled_msg_queue);
        oled_msg_queue = NULL;
    }
}
